<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <script src="md5.js" type="text/javascript"></script>
    <script>
        function S3Upload(filepath, tohash, callback) {
          //- This MD5 hash is generated so that, rather than all avatars going
          // in the bucket's root, each user has a unique directory to store
          // uploads in with no chance of name collisions with other files.
          //- We could hash on anything, it doesn't _have_ to be email, it just
          // makes it easier to reuse uploads without DB access (ie. just hash
          // the email again, instead of getting Visitor.photo_capture
          var hash = CryptoJS.MD5(tohash).toString(CryptoJS.enc.Hex);
          base64encode(filepath, function(base64) {
            var key    = document.getElementsByName('key')[0]
              , file   = document.getElementsByName('file')[0]
              , form   = document.getElementsByTagName('form')[0]
              , amazon = form.action.replace('https','http');
            key.value  = "uploads/" + hash + "/avatar.jpg.txt";
            file.value = base64;
            // The callback is passed the full URL to the upload
            callback(amazon + key.value);
            form.submit();
          });

          // to get the Base64, pretty much the same as WebWorks' File.toDataURL
          function base64encode(filepath, callback) {
            var canvas = document.getElementById('canvas')
              , ctx = canvas.getContext('2d')
              , img = new Image();
            img.onload = function() {
              var scale = rescaleFactor(img,320);
              canvas.width  = img.width  / scale;
              canvas.height = img.height / scale;
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
              callback(canvas.toDataURL());
            }
            img.src = filepath;
          }

          // scaling the image, since we don't want ~4MB avatars
          function rescaleFactor(img, maxDimension) {
            var scale = 1;
            if( img.width > img.height ) // landscape photo
              scale = img.width  / maxDimension;
            else
              scale = img.height / maxDimension;
            return scale;
          }
        }
    </script>
</head>
<body>
    <canvas id="canvas"></canvas>
    <form action="https://factory-wheatley.s3.amazonaws.com/" method="post" enctype="multipart/form-data">
        <input type="hidden" name="key">
        <input type="hidden" name="AWSAccessKeyId" value="AKIAJ7B2A346MIG3HPUA">
        <input type="hidden" name="acl" value="public-read">
        <input type="hidden" name="success_action_status" value="200">
     <!-- The policy and signature fields are generated using calculate-policy.rb
          If you change any of these input fields, you'll need to modify the policy
          contained in calculate-policy.rb, and run 'ruby calculate-policy.rb' -->
        <input type="hidden" name="policy" value="eyJleHBpcmF0aW9uIjogIjIwMTUtMDEtMDFUMDA6MDA6MDBaIiwKICAiY29uZGl0aW9ucyI6IFsKICAgIHsiYnVja2V0IjogImZhY3Rvcnktd2hlYXRsZXkifSwKICAgIFsic3RhcnRzLXdpdGgiLCAiJGtleSIsICJ1cGxvYWRzLyJdLAogICAgeyJhY2wiOiAicHVibGljLXJlYWQifSwKICAgIHsic3VjY2Vzc19hY3Rpb25fc3RhdHVzIjogIjIwMCJ9LAogICAgWyJzdGFydHMtd2l0aCIsICIkQ29udGVudC1UeXBlIiwgIiJdLAogICAgWyJjb250ZW50LWxlbmd0aC1yYW5nZSIsIDAsIDUyNDI4ODBdLAogIF0KfQo=">
        <input type="hidden" name="signature" value="digWP2EncwvugBTZoORuhYPQLNs=">
        <input type="hidden" name="Content-Type" value="text/plain">
     <!-- In Wheatley I am using a hidden input field to store the file's Base64 data.
          This is because I don't want the user/visitor to have to find their photo
          using a file dialog after they've just taken it with the camera.
          For other projects you probably want <input type="file" name="file"> -->
        <input type="hidden" name="file">
        <input type="submit" value="upload">
    </form>
</body>
</html>
